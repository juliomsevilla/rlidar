---
editor_options: 
  markdown: 
    wrap: 72
---

# Introducción al lenguaje R

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align="center")
##knitr::opts_knit$set(root.dir = 'c:/curso_lidar/')
```

## Introducción al lenguaje R

### ¿Que es R?

R o The R Project for Statistical Computing [@R-base] es un lenguaje y
entorno de programación de alto nivel, orientado a objetos y
fundamentalmente centrado al análisis estadístico y gráfico, distribuido
bajo la licencia GNU GPL y está disponible para los sistemas operativos
Windows, Macintosh, Unix y GNU/Linux.

El origen de R se remonta a 1993 cuando Robert Gentleman y Ross Ihaka
del Departamento de Estadística de la Universidad de Auckland adaptan el
[lenguaje de programación
S](https://en.wikipedia.org/wiki/S_(programming_language)), propio de
los famosos Bell Laboratories de AT&T, el cual es un sistema para el
análisis de datos desarrollado por John Chambers y Rick Becker
fundamentalmente y usado desde finales de 1970 (Ross y Robert comienzan
a llamar "R" al lenguaje que implementaron, por las iniciales de sus
nombres). Es más, muchos de los libros y manuales sobre S son útiles
para R.

### ¿Por qué usar R?

R tiene varias ventajas respecto a otros lenguajes de programación de
fines estadísticos o softwares dedicados. Entre otras podemos citar:

-   Sus posibilidades gráficas son excelentes y muy versátiles. Esto
    llega hasta el punto de que muchos que R tiene dos aspectos: el de
    software, vamos a llamarlo, analítico y el gráfico, pudiendo incluso
    independizarse su aprendizaje.
-   Cuenta con una elevada flexibilidad. Los trabajos más sencillos o
    complejos algoritmos pueden ejecutarse escribiéndose una palabra.
-   No es "una caja negra" y en todo momento sabemos que estamos
    haciendo. Este es un aspecto que no se valora como se debería cuando
    hacemos nuestros análisis estadísticos: a costa de la facilidad de
    hacer todo con un par de clicks perdemos fácilmente el control de lo
    que estamos haciendo (o incluso llegamos a desconocerlo), algo que
    no debería ser permitido, ya que quien hace un análisis busca una
    conclusión y no saber cómo se obtiene debería invalidar por si solo
    dicha conclusión.
-   En R, un análisis estadístico se realiza por pasos que arrojan
    resultados que se van almacenando en objetos. De esta forma, estos
    pueden recuperarse y usarse en cualquier momento.
-   Al contrario que otros software, permite salidas mínimas de
    resultados, fácilmente legibles y analizables, y no una salida
    copiosa de datos y gráficos.
-   Salvo que utilicemos una GUI, su aspecto es minimalista y espartano
    a conciencia (hasta su web sigue esta filosofía), siguiendo la
    filosofía de no perder el foco de atención de lo que estamos
    haciendo con el "marco" en el que lo hacemos.
-   Es libre, con filosofía y objetivos del proyecto GNU, con lo que
    podemos acceder al código escrito por otros usuarios y modificarlo
    libremente y evidentemente, podemos programar nuestras propios
    procedimientos y aplicaciones.
-   Es un proyecto vivo con dos millones de usuarios. Seguramente a
    nuestro problema ya se habrá enfrentado alguien y casi con total
    seguridad no deberemos avanzar más de "tres páginas de Google" para
    encontrar la solución.
-   Existen multitud de librerías (paquetes) programadas por los
    usuarios de todo el mundo para llevar a cabo procedimientos
    específicos (¡más de 10.000!).
-   Y si con todo ello, no tenemos suficiente, es totalmente gratuito,
    tanto el como todo su ecosistema.

### Recursos sobre R

Para aprender sobre R y estar al corriente de las últimas novedades
existen una serie de recursos que deberemos añadir a nuestros Favoritos.
Entre otros:

-   Página oficial de R: <https://www.r-project.org/>
-   Fundación R:
    [https://www.r-project.org/foundation/](https://www.r-project.org/foundation)
-   Manuales iniciales: <https://cran.r-project.org/manuals.html>
-   Revista R: <https://journal.r-project.org/>
-   R-Bloggers: <http://www.r-bloggers.com/>
-   Comunidad R-Hispano: <http://r-es.org/Comunidad>
-   Recursos MOOC como Coursera: [www.coursera.org](www.coursera.org)
-   Bibliografía en papel: "R for Everyone: Advanced Analytics and
    Graphics" (<http://www.jaredlander.com/r-for-everyone/>), "R
    Cookbook" (<http://shop.oreilly.com/product/9780596809164.do>) y el
    clásico "Modern Applied Statistics with S"
    (<http://www.springer.com/us/book/9780387954578>)

En este punto nos puede asaltar la duda ¿Markdowncubre todo el espectro
que cubre `HTML`? Sí y no, porque si no lo cubre, tan solo tienes que
escribir la parte de HTML\` separado una línea del siguiente párrafo en
Markdown.

Trabajar con Markdown, tiene infinidad de ventajas, pero es
especialmente adecuado para aquellas personas que publican contenido en
la web de manera regular. Entre otras ventajas cabe citar que cuando te
acostumbras a la sintaxis la generación de texto es extremadamente
rápido, es muy sencillo de leer, no tendremos el problema de errores por
no cerrar adecuadamente las etiquetas `HTML` y su compilación con
software como [`Pandoc`](https://pandoc.org/) permite la exportación
simple a infinidad de formatos basados en texto.

## Instalación de R, RStudio y librerias

### Instalación de R

R funciona bajo Windows, Linux, Mac o Solaris. Para instalar R
accederemos a su página (en este caso, un mirror de España):
<http://cran.es.r-project.org/> y descargaremos la versión adecuada a
nuestro sistema operativo.

En el caso de Windows, la instalación es muy sencilla y solo deberemos
seguir los pasos que se nos indica. Si todo ha ido correctamente, cuando
pulsemos sobre el icono de R, se abrirá su espartana interfaz en la que,
además de la barra de herramientas, destaca la consola donde
escribiremos y ejecutaremos nuestro código.

Algo bastante interesante de R es su portabilidad. R, una vez instalado
en un PC puede funcionar de forma autónoma al mismo. Por ello, una
simple copia del directorio donde lo hayamos instalado y su posterior
"pegado" en una memoria flash, nos permitirá ejecutarlo en cualquier
lugar, llevándonos así nuestra configuración personal, paquetes,
entornos y demás.

## Actualización de R

Cada cierto tiempo es recomendable realizar la actualización de R.
Generalmente, un par de veces al año, el sistema es actualizado, misión
que lleva a cabo un reducido grupo de especialistas (conocido como el R
Core team) y los paquetes (que en próximos capítulos explicaremos) se
adaptan a la nueva actualización, dejando, algunas veces de ser útiles
en las versiones obsoletas.

La actualización de R puede ser automatizada o realizarse de forma
manual si bien este último recurso no es la mejor opción debido a que se
actualizará creando una nueva instalación manteniendo la anterior. Este
echo se debe a que en la actualidad es la única forma de que no perdamos
nuestras configuraciones y, sobre todo, la posible incompatibilidad con
alguno de los paquetes que tengamos instalados.Para realizar una
actualización automática del sistema, podemos usar la siguiente
sentencia usando el paquete [@R-installr] (despues veremos el lugar de
ejecutarla):

```{r eval = FALSE, message=F, warning=F}
if(!require(installr)) {
  install.packages("installr"); require(installr)} 
 
updateR()
```

### El Sistema R

Una vez instalamos R, nos encontramos con una interfaz gráfica de
usuario que nos puede resultar "anticuada" sobre todo si trabajamos con
los sistemas operativos más recientes. Este aspecto no debe confundirnos
de cuál es la visión del sistema R: un lenguaje de programación con una
clara vocación estadístico-matemática.

![R](https://egret.psychol.cam.ac.uk/statistics/R/output/R_startup.png)

## Gestión de directorios, archivos y versiones

### Gestión de directorios

Existen dos comandos básicos para trabajar con directorios: `setwd()` y
`getwd()`. El primero, fija el directorio de trabajo que deseamos y el
segundo lo llama.

Con el directorio fijado, podremos movernos por él, usando el comando
`"./data"` que nos haría descender a una carpeta llamada data que cuelga
de nuestro directorio raíz fijado con `setwd()`. Por otro lado, si
usamos el comando `"../data"` ascenderemos a una carpeta que esta en un
nivel superior a nuestro directorio raíz.

A continuación, podemos usar los comandos `list.files()` y `list.dirs()`
para poder listar los archivos y directorios respectivamente que
tengamos en el directorios elegido. Es interesante indicar que si
añadimos la opción `recursive=TRUE` los dos comandos listaran todos los
ficheros y archivos que haya tanto en nuestro directorio raiz como en
todos los inferiores. Finalmente, usando el comando `full.names = TRUE`
en vez de solo mostrarnos el nombre completo del fichero, nos mostrará
toda su ruta.

Ahora combinemos todo lo anterior para listar los ficheros de un
directorio:

```{r eval = FALSE}
list.files("c:/")
list.dirs("c:/")
```

Finalmente, con el comando `pattern =` podremos seleccionar determinados
ficheros o directorios que coincidan con una determinada condición. Por
ejemplo, `pattern = "(.*).jp2$"` nos mostrará todos los ficheros que
finalicen la extensión `jp2` y `pattern = "29SMD(.*)SCL_20(.*).jp2$"`
nos listará todos los ficheros que además de finalizar con `jp2`incluyan
la cadena `29SMD` y `SCL_20`.

Una vez tenemos claro los conceptos anteriores, podremos realizar
trabajos recursivos con nuestros ficheros y directorios (tranquilo,
comprenderás este código a lo largo de estos apuntes), por ejemplo:

```{r eval = FALSE}
List <- list.files(getwd(), full.names = TRUE, 
                   pattern = "29SMD(.*)SCL_20(.*).jp2$", 
                   recursive=TRUE) 
for (file in List) { 
  out_file <- extension(file, 'tif') 
  gdal_translate(src_dataset = file, dst_dataset = out_file, 
                 ot = "UInt16", of = "GTiff") 
} 
```

### Manejo de archivos

Cuando cargamos un fichero externo, sea del formato que sea, R, por
defecto lo interpretará como un `data.frame` (ver \@ref(dataframe)), si
este viene en un formato usual de tabla.

R puede cargar multitud de ficheros distintos y si no lo hace con las
opciones incluidas en ´{base}´ lo hará a traves de librerias. Veamos a
continuación los más frecuentes.

#### Ficheros csv

Los ficheros delimitados por comas se cargan con el comando `read.csv`
indicando al menos la ruta del mismo, si viene o no con cabeceras, el
separador decimal y el separador de colummas:

```{r eval = FALSE}
datos<-read.csv("./datos.csv", header=TRUE, dec= ".", sep=",")
```

En el caso de no indicar, `header`, `dec` y/o `sep`, el comando
`read.csv` importará el fichero con el primer registro como cabeceras,
el separador decimal en forma de `.` y el separador de columnas `,`.

En ocasiones, nuestro fichero puede venir sin cabeceras por lo que
deberemos importarlo indicando este echo y R se encargará de crearlas y
nombrarlas automaticamente:

```{r eval = FALSE}
datos<-read.csv("./datos2.csv", header=FALSE, dec= ".")
```

En este último caso, si deseamos que en vez de los nombres de cabecera
que crea R, tener unos personalizados, deberemos decírselo al realizar
la importación:

```{r eval = FALSE}
datos<-read.csv("./datos2.csv", header=FALSE, 
                dec= ".", col.names = c("id", "factor", "volumen"))
```

Para finalizar, nuestros ficheros pueden venir con valores nulos. Si los
conocemos, deberemos indicarselo al comando `read.csv` mediante
`strings.na`. Por ejemplo (todos los valores que en el fichero vengan
con `N/A` los entederá como un valor nulo):

```{r eval = FALSE}
datos<-read.csv("./datos3.csv", header=TRUE, strings.na= "N/A")
```

Un añadido: en ocasiones los ficheros comienzan con líneas explicativas
que no sirven para nada en el contexto de datos tabulares. Para saltar
estas lineas podemos usar el comando `skip=` dentro de `read.csv()`.

### Carga de datos usando el buscador

En ocasiones, sobre todo si nuestro código lo compartimos con otros, es
conveniente dejar la forma de entrada de nuestros datos a libre elección
y que se localicen con el buscador del sistema. Para ello, haremos uso
de la función `file.choose()`:

```{r eval = FALSE}
filename <- file.choose()
data <- read.csv(filename, header=TRUE, dec= ".", sep=",")
```

#### Carga de datos desde una ruta web

Generalmente nuestros ficheros estarán alojados en nuestro PC, pero en
la actualidad, cada vez es más frecuente que los mismos estén alojados
en un servidor de la web. La carga de estos no difiere en nada de la
carga de un fichero ubicado en nuestro local. Para ello, en vez de una
ruta de carpetas de nuestra computadora, pondremos la url donde se aloje
el fichero y nos ayudaremos de la librería `RCurl` [@R-RCurl] que
facilita el trabajo de lectura y descarga:

```{r eval = FALSE, message=F, warning=F}
library(RCurl)
datos_online <- read.csv(
  text=getURL("https://raw.githubusercontent.com/juliomsevilla/rlidar/main/data/parc.csv"), 
  header=TRUE)
```

En ocasiones la librería `RCurl` [@R-RCurl] falla (en Windows
especialmente y/o si estamos antes de un proxy), por lo que podemos
optar a la opción sencilla de descargar el fichero directamente:

```{r}
download.file("https://raw.githubusercontent.com/juliomsevilla/rlidar/main/data/parc.csv", 
              destfile = "c:/temp/test.csv", method = "curl")
```

#### Scrapping

Una rutina bastante usual es descargar datos desde una web (a diferencia
del anterior, no es un fichero alojado en una servidor). A este
procedimiento se le denomina *scrapping* y usualmente deberemos
comprender ficheros del tipo `xml`o `json` (comprender, ya que no son
estructuras rígidas como puede ser una "tabla" de un `csv`).

En el caso de `xml` nos apoyaremos en la libreria `XML` [@R-XML] el
procedimiento consistirá en cargar la ruta en la que se aloja dicho
elemento y a continuación indicarle a `R` cual es el nodo raíz para
finalmente ver que datos hay encerrados entre las etiquetas `<>`.

```{r eval = FALSE, message=F, warning=F}
library(XML)
library(RCurl)
url<-getURL("https://raw.githubusercontent.com/juliomsevilla/rlidar/main/data/test.xml")

xmldoc<-xmlParse(url)
rootnode<-xmlRoot(xmldoc)
rootnode[1] #De esta forma podremos ver el registro número 1

datos_raw<-xmlSApply(rootnode, function(x) xmlSApply(x, xmlValue)) #Carga los datos fila a fila
datos<-data.frame(t(datos_raw), row.names =NULL) #Hacemos una transposición para aplicar correctamente las etiquetas como cabeceras

```

Como sabemos `HTML` no deja de ser una formulación especial de `xml` y,
por tanto, podremos usar lo anterior para extraer información de una
web, web, hecha con lenguaje `HTML`

```{r eval = FALSE}
url<-getURL("https://raw.githubusercontent.com/juliomsevilla/rlidar/main/data/poblacion.html")
tables<-readHTMLTable(url) #Nos extrae todas las tablas que hay en el fichero HTML
tabla1<-tables[[3]] #Extraerá la tabla 6 y se usan dos corchetes porque se busca en una lista de listas
tabla2<-readHTMLTable(url, which=3) #Idem al anterior pero no cargamos en local toda la web, ahorrando memoria

```

Ahora hablemos de los ficheros `json` ficheros mucho más comunes para
compartir datos y más eficientes en este sentido que `xml`. la librería
que nos facilita el trabajo es `jsonlite` [@R-jsonlite]

```{r eval = FALSE, message=F, warning=F}
library(jsonlite)
library(RCurl)
url<-"https://raw.githubusercontent.com/juliomsevilla/rlidar/main/data/currencies.json"
currencies<-fromJSON(url)
```

Si analizamos la estructura del fichero `json`veremos que como en el
caso de `xml`es un conjunto de tados anidadados en etiquetas. Para poder
extraer solo lo que nos interesa, podemos hacer uso del simbolo `$` y
crearnos un solo objeto con los datos que nos interese (es bastante util
ir recorriendo la estructura según nos propone el predictor de `RStudio`
a medida que vamos poniendo el símbolo `$`)

```{r eval = FALSE}
datos<-currencies$list$resources$resource$fields
```

#### El fichero Rdata

`R` por defecto trabaja con un sistema de archivos propio, denominado
con la extensión `*.Rdata`. Estos ficheros conservará todos los
elementos tal y como los tengamos en la memoria una vez lo creemos, por
lo que resultan bastante útiles para compartir ciertos elementos de
nuestras sesiones que hayamos trabajado.

```{r eval = FALSE}
cliente<-c("Pepe", "Juan", "Julio")
fecha<-as.Date(c("2018/1/14", "2018/12/26", "2018/11/15"))
cantidad<-c(11.1, 16.18, 26.25)
datos<-data.frame(cliente, fecha, cantidad)
save(datos, currencies, file = "c:/Borrar/clientes.Rdata")
load("c:/Borrar/clientes.Rdata")
```

Existe otro formato de fichero en R, denominado `rds` que difiere del
anterior en que este no almacena el nombre del objeto, por lo que cuando
lo carguemos deberemos asignarle el nombre que queramos tener en nuestra
sesión y, y esto es lo más importante, solo es capaz de guardar un solo
objeto. Para guardar o cargar este fichero, usaremos los comandos
`loadRDS` y `saveRDS` (en este último caso, guardando con la extensión
`*.rds`).

Finalmente, dentro de `R` podemos usar un comando muy interesante:
`save.image(file="")` el cual nos permite guardar en un fichero `Rdata`
toda nuestra sesión, permitiéndonos así hacer portable nuestro trabajo.

### Limpieza de la memoria en `R`

A medida que vayamos trabajando en nuestro análisis, la memoria del
sistema se irá llenando pudiendo llegar a abortar la sesión (depende la
memoria RAM de nuestra computadora). Por ello, es recomendable ir
eliminando aquellos objetos que no vayamos a utilizar nuevamente con el
comando `rm`:

```{r eval = FALSE}
rm(datos, tabla1) #Elimina el objeto datos y tabla1
rm(list=setdiff(ls(), c("cantidad", "cliente"))) #Elimina todos los objetos de la memoria menos
rm(list=ls()) #Elimina todos los elementos de la memoria
.rs.restartR() #Reinicia la sesión de R, eliminando cualquier resto que pudiera quedar
```

### Control de versiones

Para comenzar necesitaremos contar con el software Git en nuestro pc.
Podemos hacerlo de dos formas: descargandolo e instalando la versión de
nuestro sistema operativo o usando una versión portable. Desde aquí
recomendamos
[https://www.syntevo.com/smartgit/download/](Smartgit%20portable), bien
para usarlo o solo para utilizar el git portable.

Una vez lo descomprimes vamos a RStudio y en Tools\>Global
Options\>Git/SVN se le indica donde está git.exe, que está dentro de la
instalación de git portable en la carpeta bin (generalmente en
/git/bin/git.exe).

A continuación abrimos el shell de git (/git/git-cmd.exe) y pondremos
los siguientes comandos sustituyendo con nuestros datos lo que viene
dentro de las comillas.

`git config --global user.name 'Your Name'`

`git config --global user.email 'your@email.com'`

Crear un proyecto control de versiones es muy sencillo: creamos el
proyecto habilitando el sistema de versioneado (checkbox "Create a git
repository" dentro de File\>New Directory\>New Project). Para clonar un
repositorio creamos un nuevo proyecto y le decimos que este sea con
control de versiones (File\>Version Control) y ahí podremos introducir
la dirección http del repositorio. También tendremos que indicarle donde
lo guardaremos. Despues de ello, RStudio añadirá un botón, en la barra
de herramientas principal, para gestionar el control de versiones
(simbolizado con las letras GIT).

Trabajar con un sistema de control de versiones daría para un libro
completo sobre el tema por lo que no vamos a profundizar. Básicamente,
nuestro trabajo se basará en realizar commits cada vez que deseemos
fijar una foto de nuestros cambios y ejecutar pull/push de nuestros
repositorios cuando queramos traernos los cambios a local o subirlos al
servidor respectivamente. Indicar que en estas dos acciones, se abrirá
un diálogo que nos solicita nuestro usuario y contraseña. Para
profundizar en el tema es muy recomendable visitar el manual de Jenny
Bryan [Happy Git and GitHub for the useR](http://happygitwithr.com/) y
el video oficial de RStudio dentro de la serie [RStudio
Essentials](https://www.rstudio.com/resources/webinars/rstudio-essentials-webinar-series-managing-part-2/)

### Buenas prácticas en la gestión de un proyecto

Con frecuencia nos veremos envueltos en la gestión de proyectos de
envergadura donde se mezclarán ficheros de datos creados y externos,
scripts, elementos de consulta, documentación e incluso información
temporal. Por ello, es recomendable ser disciplinado y crear una
estructura de directorios adecuada.

A continuación se dan unas ideas, adecuables a cada situación:

1.  Tratar los datos originales como de sólo lectura

2.  Limpiar los datos previamente, incluso fuera de R

3.  Usar herramientas de control de versiones como `Git` o `SVN`

4.  Empezar siempre nuestra sesión definiendo el directorio de trabajo y
    que este sea fijo

5.  Siempre trabajar con la misma estructura de directorios, aunque
    tengamos carpetas vacias. Por ejemplo, dentro de del directorio raíz
    de nuestro proyecto (cada proyecto contará con uno), crear las
    siguientes carpetas:

    -   bin: para guardar todos aquellos elementos accesorios para poder
        realizar los análisis (scripts de otros lenguajes, por ejemplo)
    -   data: donde almacenaremos todos los datos de inicio,
        metadata,...
    -   doc: para poder guardar toda la documentación generada como
        wikis o manuales
    -   results: para guardar los datos limpios de nuestro análisis y
        los resultados
    -   src: para almacenaje de scripts creados
    -   temp: para almacenar los archivos temporales y prescindibles

6.  Escribir código legible y que este sea lo más pequeño posible ("un
    elefante nos lo podemos comer a pequeños bocados")

7.  Siempre documentar tu proyecto, hasta lo más simple

## Manejo de objetos en R

### R como calculadora

R es una potente calculadora pero quizás sea para lo que menos se usa.
Su utilización es tan simple como escribir lo que queremos realizar
(hagamos nuestro "Hello, World" sumando 1+1:

```{r}
1+1
```

### Manejo de variables

Las variables, entendidas en R como en cualquier lenguaje de
programación, son el núcleo sobre el que gira todo el sistema, si bien
en este sistema se denominan objetos. Estas se asignan con los
operadores `<-` o `=` y con la función `assing()`, prefieriéndose el
primero.

```{r eval=FALSE}
a<-1
a
b=2
b
c<-d<-3
c
d
assign("e", 13)
e
3->f
f
```

Todas los objetos en R se realizan con objetos que son guardados en la
memoria activa del ordenador, sin usar archivos temporales, por lo que
deberemos tener muy en cuenta la RAM de nuestra máquina.

Es importante destacar que si un objeto existe con una valor, si le
asignamos otros, el primero cambia irremediablente:

```{r eval=FALSE}
a
a<-45
a
```

Por otro lado, el valor asignado a un objeto puede ser el resultado de
una operacion y/o de una función:

```{r eval=FALSE}
n <- 5 + rnorm(1)
```

En ocasiones, y para abreviar, podremos encontrarnos con comandos en una
sola línea: si estos están separados con `;` se ejecutarán de forma
independiente:

```{r}
a<-1; b<-2; a; b
```

A veces podremos querer listar los objetos que existen en memoria, para
lo cual usaremos `ls()`:

```{r}
ls()
ls(pat = "m") # Lista aquellos objetos que contengan una m
```

## Manejo de datos en R

### Tipos de datos

El dato en R es un concepto distinto al que estamos acostumbrados a
tratar en Estadística Aplicada y se debe entender como el resultado de
ejecutar una determinada expresión, es decir, es un objeto.

En otros, los tipos de datos (objetos) fundamentales de R son:

-   Vectores. Conjunto de elementos en un determinado orden.
-   Factores. Vector donde sus elementos provienen de un número finito
    de categorías.
-   Matrices. Estructura de datos bidimensional de valores de igual tipo
-   Listas. Estructura de datos más amplia que y puede contener
    colecciones arbitrarias de datos
-   data.frame. Estructura de datos bidimensional de elementos, cuyas
    columnas pueden estar formadas por elementos de distinto tipo

Como vemos unos se diferencian de otros en función de los tipos de
elementos que contienen. Estos elementos poseen distintos atributos,
pero de ellos, para nuestros propósitos hemos de destacar el modo. En
concreto, en R, distinguimos cuatro modos:

-   Lógico o modo binario, verdadero o falso (T o F, respectivamente)
-   Númerico, donde los valores posibles son números reales
-   Complejo, donde los valores posibles son números complejos
-   Carácter, donde los valores son caracteres (separados por comillas)
-   Fechas, definidas en formato "2015-06-25" o "2015-06-25 15:15"

#### Vectores

Es uno de los tipos de datos más utilizados. Como regla ineludible es
que sus elementos sean del mismo modo.

Su creación se realiza a través de la función `c` (del inglés
*concatenate*), siguiendo la siguiente estructura:

```{r}
x<-c(118, 160, 64, 138, 168, 140, 109, 135, 220, 180, 151, 129, 117, 121, 86, 170, 62, 104, 184)
z<-c("a", "a", "b", "c", "a", "c", "b", "a", "c", "b", "c", "c", "b", "b", "a", "a", "a", "b", "c")
w<-c(5:-7)
w
```

El trabajo con objetos de R tiene grandes ventajas. Una de ellas es el
crear datos a partir de otros o ejecutar operaciones con ellos.

```{r}
x1<-c(118, 160, 64, 138, 168)
x2<-c(140, 109, 135, 220, 180)
x3<-c(x1, 140, 109, 135, 220, 180, 151, 129, 117, 121, 86, 170, 62, 104, 184)
x1*x2
(x1^2)/(x2)
```

Si, deseamos saber las características del vector creado, podemos usar
funciones como las siguientes:

```{r}
mode(x)
length(x)
```

Otras funciones útiles son las que se enumeran a continuación:

```{r}
is.numeric(x) #Pregunta si es numérico
class(x) #Indica el tipo de valor
nchar(z) # Cuenta el número de caracteres
```

#### Factores

Los factores son uno de los tipos de datos más importantes en
Estadística Aplicada. Su definición en R es muy sencilla y se hace con
la instrucción siguiente (nos apoyaremos en el vector z, anteriormente
creado):

```{r}
f<-as.factor(z)
```

Existen comandos asociados a los factores bastante útiles. De ellos
destaca `levels`, que nos indica los niveles del factor:

```{r}
levels(f)
```

### Valores perdidos y nulos

El tratamiento de estos tipos de valores es muy simple en R. Los valores
perdidos se definen como `NA` y a diferencia de un valor nulo,`NULL`,
implica la existencia de valor. Esto se puede ver fácilmente con el
siguiente comando:

```{r}
s<-c(1, NA, 3, 4)
r<-c(1, NULL, 3, 4)
s
r
length(s)
length(r)
```

Si contamos con valores perdidos, es de vital importancia no tratarlos
en nuestros análisis. Para ello, usaremos el comando `na.rm=T`:

```{r}
mean(s)
mean(s, na.rm=T)
```

Para finalizar, en R, hemos de evitar confundir `NA` con `NaN`. Mientras
el primero, como hemops indicado responde a la inexitencia de valor, el
segundo representa las siglas "Not a Number", siendo arrojado por el
porgrama cuando el resultado de un determinado cálculo así lo sea.

```{r}
sqrt(-23)
0/0
```

#### Gestión de valores `NA`

Cuando cargamos un fichero de datos que contiene datos vacios, podremos
transformarlos a `NA` usando el comando `na.strings=""` poniendo dentro
de las comillas el valor que represente ese dato vacio (si efectivamente
el vacio lo es, lo podremos indicar no poniendo nada dentro de estas
comillas).

```{r message=F, warning=F}


download.file("https://raw.githubusercontent.com/juliomsevilla/rlidar/main/data/parcna.txt",
              destfile = paste(tempdir(), "\\parcna.txt", sep=""), 
              method = "curl", overwrite=TRUE)

data <- read.table(paste(tempdir(), "\\parcna.txt", sep=""), na.strings="na", header=TRUE)


```

En ocasiones podríamos querer despreciar esos casos que contienen
valores `NA`: lo haremos facilmente con la sentencia `na.omit()`.

```{r}
data_clean<-na.omit(data) #Observemos que se ha reducido el número de registros respecto al objeto data
```

Hagamos algo más complejo: quedemosnos con aquellos registros donde no
existan `NA` en un determinado campo `myfield` (usaremos `!` que es el
indicador de negación, el concepto `is.na` y los corchetes para
señalizar filas y/o columnas).

```{r}
new_data<-data[!is.na(data$COMARCA),]
```

Parecido a lo anterior, si quisieramos quedarnos solo con los registros
completos, es decir, con solo aquellos que no tienen `NA`en ninguna
columna, podríamos hacer:

```{r}
new_data.2<-data[complete.cases(data),]
```

Finalmente, si quisieramos convertir un determinado valor a `NA`
podríamos ejecutar:

```{r}
data$AB[data$HD==0]<-NA
```

##### Reemplazar valores `NA` con parámetros de la muestra

Como se ha dicho anteriormente, al calcular parámetros de nuestra
muestra y contar con valores `NA` el resultado será `NA` salvo que le
indiquemos que no lo tenga en cuenta con `na.rm`. De esta forma,
evitaremos el error, pero, por contra, perderemos registros de nuestro
`data.frame` si este cuenta con más.

Por ello, en ocasiones es adecuado reemplazar esos valores con el
parámetro que estemos calculando:

```{r}
data$NC<-ifelse(is.na(data$NC), 
                         mean(data$NC, na.rm = TRUE),
                         data$NC)
```

Esta opción es adecuada para variables continuas. En el caso de
variables categóricas, podemos asignar un valor aleatorio, de todos los
posibles con los que contamos en ese caso.

```{r}
rand.impute<-function(x){ # x es un vector de datos que puede contener NA
  missing<-is.na(x) # missing es un vector que contiene TRUE o FALSE en función de que x sea NA o no
  n.missing<-sum(missing) #sumamos missing y obtenemos el número de verdaderos y por tanto obtenemos cuantos NA tenemos
  x.obs<-x[!missing] # Obtenemos que datos tienen valor diferente de NA en x, es decir, me quedo con los que no son NA
  imputed<-x
  imputed[missing]<-sample(x.obs, n.missing, replace = TRUE) #Extraemos una muestra aleatoria de los datos que conocemos, x.obs, de un tamaño n.missing, y los asignamos a los que no conocemos
  return (imputed)
}

random.impute.dataframe<- function(dataframe, cols) {
  names<-names(dataframe)
  for (col in cols){
    name<-paste(names[col], ".imputed", sep="")
    dataframe[name]=rand.impute(dataframe[,col])
  }

}
data2<-data
random.impute.dataframe(data2,c(1,3))
```

##### Eliminar registros `NA`

Las más de las veces, querremos eliminar los datos `NA`. Para ello,
haremos uso del comando `na.omit`:

```{r}
data_na.omit<-na.omit(data)
```

### Registros duplicados

La gestión de los registros duplicados es muy sencilla en R con la
función `unique()`

```{r}
data2<-unique(data)
```

### Reescalado

Para que funcionen mejor muchos algoritmos, hay que normalizar las
variables de entrada al algoritmo. Por Normalizar conocemos la técnica
que nos permite comprimir o extender los valores de la variable para que
estén en un rango definido. Asímismo, es bastante interesante usar esta
técnica con variables con dispersiones muy grandes (es decir con valores
muy elevados y muy pequeños). El trabajo de normalización se puede
realizar facilmente con la libreria `scales` [@R-scales]

```{r message=F, warning=F}
library(scales)
data$VSC.rescaled<-rescale(data$VSC) 
#El valor más pequeño tomará el valor cero y el más alto tomará el valor uno. El resto se escala de forma líneal:
data$VSC.rescaled.manual<-(data$VSC-min(data$VSC))/(max(data$VSC)-min(data$VSC))
data$VSC.rescaled.100<-rescale(data$VSC, to=c(0,100)) 
```

En el caso que quisieramos reescalar varias columnas, podríamos hacer
uso de un bucle:

```{r}
rescale.all<-function(dataframe, cols){
  names<-names(dataframe)
  for (col in cols){
    name<-paste(names[col], "rescaled", sep=".")
    dataframe[name]<-rescale(dataframe[,col])
  }
  dataframe
}

data2<-data
data2<-rescale.all(data2, c(4,5))
```

### Normalizado y estandarizado

Las más de las veces realizamos pruebas, modelos o simplemente estimamos
valores de parámetros en los que es obligatoria la existencia de
normalidad en nuestros datos. Se entiende por variable normal aquella
cuya distribución de probabilidad se ajusta una curva acampanada en la
que la media aritmética, la mediana y la moda de la distribución son
iguales y se localizan en el pico. Así, la mitad del área bajo la curva
se encuentra a la derecha de este punto central y la otra mitad está a
la izquierda de dicho punto.

No es la única función de distribución, pero si es la más común y una de
sus características más importantes es que casi cualquier distribución
de probabilidad, tanto discreta como continua, se puede aproximar por
una normal bajo ciertas condiciones. Por ello, la mayoría de los
estdísticos más rutinarios exigen la existencia de normalidad para
validar las hipótesis.

El análisis de la normalidad se puede hacer de una forma rudimentaria
comprobando si la media, mediana y moda son "iguales" o de una forma más
compleja a raíz de pruebas de hipótesis como la de Kolmogorov-Smirnov o
el test de Shapiro. Asimismo, gráficamente, representando el histograma
de frecuencias o con gráficos de cajas (box-plot) podremos comprobar su
cumplimiento.

En R, estas pruebas forman parte del núcleo del software, usándose los
siguientes comandos para comprobarla:

```{r}

mean(data$VSC) # Media aritmética
median(data$VSC) # Mediana

shapiro.test(data$VSC) #Test de Shapiro (para pruebas con más de 50 datos)
ks.test(data$VSC, "pnorm", mean(data$VSC), sd(data$VSC)) # Test de Kolmogorov
par(mfrow=c(2,2)) # Representación gráfica
plot(data$VSC)
hist(data$VSC)
boxplot(data$VSC)
qqnorm(data$VSC)
par(mfrow=c(1,1)) 
```

Muchas veces la no existencia de normalidad puede ser solucionada con
una transformación de los datos. La transformación consiste en aplicar
una determinada operación matemática, de forma que una vez aplicada la
variable alcance cierto grado de normalidad. En general con variables
cuya distribución esté sesgada a la izquierda, la normalidad se puede
alcanzar con aplicando el logaritmo neperiano de la misma (así
comprimiremos la cola de la izquierda y extenderemos la de la derecha.).
Si, por el contrario, la distribución está sesgada a la derecha, la
aplicación de una raíz cuadrada puede solucionar el problema.

Otras veces, el alcanzar la normalidad no es tan sencillo y es necesario
utilizar transformación en las que entran en juego potencias. En este
sentido destaca la conocida tranformación planteada por Box y Cox. En R
su consecución se realiza a partir de la aplicación de librería `car`
[@R-car]

```{r message=F, warning=F}
library(car)

summary(powerTransform(data$VSC))

```

La variable transformada será `(-1+datos^"Est.Power")/("Est.Power")`:

```{r}
data$VSC.transform<-(-1+data$VSC^0.4838)/(0.4838)
par(mfrow=c(2,2)) # Representación gráfica
plot(data$VSC.transform)
hist(data$VSC.transform)
boxplot(data$VSC.transform)
qqnorm(data$VSC.transform)
par(mfrow=c(1,1)) 
```

Finalmente, en ocasiones nos interesará estandarizar (o tipificar)
nuestras variables, esto es, que nuestra variable se convierta en otra
con una distribución de media cero y desviación típica 1. Esto se
consigue facilmente con el comando `scale()`.

```{r}
data$VSC.tip<-scale(data$VSC)
mean(data$VSC.tip)
sd(data$VSC.tip)
```

### Categorizar los datos

Muchas veces nos interesará categorizar los datos en rangos en función a
un valor numérico. Para ellos, haremos uso de la función `cut`:

```{r}
cortes.num<-c(-Inf, 16, 25, 40, Inf)
cortes.label<-c("bajo", "medio", "alto", "muy alto")
data$VSC.cat<-cut(data$VSC, breaks = cortes.num, labels = cortes.label)
```

Siguiendo con lo anterior, al realizar ciertos análisis como los de
regresión, la variable dependiente y las independientes no solamente
pueden estar dadas por variables cuantitativas: existen otros tipos de
variables de carácter cualitativo. Dichas variables se conocen
comúnmente como variables dummy y usualmente, dichas variables indican
la presencia o ausencia de una cualidad o atributo, tomando valor de 1
en una submuestra y 0 en el resto de la muestra.

La gestión de este tipo de variables podemos hacerlo con la libreria
`dummies` [@R-dummies].

```{r message=F, warning=F}
library(dummies)
data.dummy<-dummy.data.frame(data, sep=".")
head(data.dummy)
data.dummy2<-dummy.data.frame(data, names=c("COMARCA"), sep=".") # Solo lo aplicamos a una o varias variables en vez de a todas las categóricas del data.frame
head(data.dummy2)
```

Finalmente, la eliminación de un objeto se debe realizar con el comando
`rm`:

```{r}
rm(a)
```

## Profundizando en el `data.frame`

### Introducción

Las más de las veces nuestras estructuras de datos se enmarcarán dentro
de "tablas" clásicas y son necesiarias para la amplia mayoría de
análisis estadísticos.Estas tablas, en R, se denominan `data.frame` y,
lo más común es que partamos de una tabla con datos y con ella y sobre
ella ejecutemos nuestros análisis.

R, como tal, no dispone de un sistema visual para gestionar las tablas
por lo que deberemos conocer los rudimentos para procesarlas y
adaptarlas a nuestros requerimientos una vez las tengamos en la memoria
despues de haberlas cargado tal y como se explicó en el capítulo
\@ref(data).

### Visualizar tablas

Generalmente comenzaremos visualizando nuestra tabla. Para ello, R
dispone, entre otros de los sigueintes comandos (comenzaremos cargando
el fichero `iris`):

```{r eval=FALSE}
iris
plot(iris) # hace una representación gráfica
summary(iris) #calcula los estadísticos descriptivos
head(iris) #extrae los 6 primeros registros
tail (iris) #extrae los 6 últimos registros
names(iris) # muestra las cabeceras de las columnas
dim(iris) # visualiza las dimensiones de filas y columnas de la tabla

```

### Extracción de datos en nuevos `data.frame`

Un recurso muy interesante de R es como extrae los datos del
`data.frame`. Veamos algunos ejemplos:

```{r  eval = FALSE}
iris[1:10,] #extrae las 10 primeras filas
iris[,1:3] #extrae las 3 primeras columnas
iris[1:10,1:3] #extrae las 10 primeras filas y de las 3 primeras columnas
iris[c(2,5,8),] #extrae las filas 2, 5, y 8
iris[, c(1,3)] #extrae las columnas 1 y 3
```

Por otro lado, si no conocemos el número de columna del campo que
deseamos, siempre podremos, evidentemente, extraerlo con su nombre:

```{r eval=FALSE}
iris[, "Sepal.Width"]

```

Finalmente, si deseamos extraer determinados elementos con expresiones
lógicas, podremos hacerlo con un simple comando:

```{r eval=FALSE}
iris[iris$Species == "setosa",]
```

### Gestionar los `data.frame`

Si antes nos referiamos a la visualización y extracción de los
elementos, veamos ahora como se gestionan los `data.frame`en su
conjunto.

Para añadir una columna, lo haremos añadiendo una variable dentro de
ella:

```{r}
datos<-iris
datos$Petal.Area <- datos$Petal.Length * datos$Petal.Width
head (datos)
```

Y para eliminarlas, lo podremos hacer *anulando* la columna deseada:

```{r}
datos$Petal.Area <- NULL
head (datos)
```

Por otro lado, podremos desear ordenar los datos de una determinada
manera.Para ello, haremos uso de `order`:

```{r}
datos2 <- iris[order(iris$Sepal.Width),]
```

### La libreria `dplyr`

En este punto, si bien como se ha descrito en los puntos anteriors R, en
su versión `base` es bastante potente en la gestión de los `data.frame`,
es adecuado destacar el paquete `dplyr` [@R-dplyr]que entre otras cosas,
hace más natural la gramática de trabajo con las tablas.

La sintaxis grámatica de esta libreria facilita la gestión de los
elementos ya que las peticiones y comandos se hacen con las palabras
habituales en otros softwares, lo que nos descarga en gran medida de
memorizar comandos recurrentes. Veamos algunos ejemplos:

```{r message=F, warning=F}
library (dplyr)
datos<-iris
subset <- select(datos, Sepal.Width:Species) #extrae las columnas que van de Sepal.Width:Species
Petal.Length.5<- filter(datos, Petal.Length > 5) #extrae aquellas filas donde Petal.Length es mayor de cinco
Petal.Length.order <- arrange(datos, desc(Petal.Length)) #Extrae un nuevo data.frame ordenado por Petal.Length de forma descendente
Petal.Length.rename<-rename(iris, Long.Petalos=Petal.Length, Ancho.Petalos=Petal.Width) #Renombra determinadas columnas
iris.Petal.Area <- mutate(iris, Petal.Area = Petal.Width*Petal.Length) #Añade una nueva variable al data.frame
iris.aleat<-sample_n(iris, 4) #Extrae aleatoriamente cuatro registros
iris.aleat.025<- sample_frac(iris, 0.25, rep=TRUE) #Extrae un 25% de obs con reemplazamiento
```

Mención aparte requiere el operador `%>%`. Este permite concatenar
varias secuencias de comandos aliviando drásticamente nuestro código:

```{r}
iris.2<- select(iris, contains('Petal'))
iris.3<- filter(iris.2, Petal.Length > 4)
iris.4<- arrange(iris.3, Petal.Length)
head(iris.4)


iris.5<-iris %>%
  select(contains('Petal'))  %>%
  filter(Petal.Length > 4)   %>%
  arrange(Petal.Length)
head(iris.5)

```

Para finalizar, queda mencionar que la concatenación de los comandos de
`dplyr` con el operador `%>%`permite crear estructuras no definidas en
el paquete, pero que son de uso recurrente. Veamos como calculamos unos
subtotales de nuestra tabla `iris`por especie:

```{r}
iris.summarize<-iris %>%
  group_by(Species) %>%
  summarise(mean(Petal.Length))%>%
  rename(Especies=Species, Long.Petalos.media=`mean(Petal.Length)`) #Notese las comillas en el campo mean(Petal.Length) que no está en el campo Species
```

## Estructuras de control

### Introducción

Las estructuras de control en R nos permiten automatizar los flujos de
programación y las secuencias de comandos, haciendo que trabajos
reiterativos sena más sencillos y abordables (no confundir con las
funciones, que se abordarán en el capítulo \@ref(functions)).

Las estructuras de control más utilizadas son:

-   `if / else`: el fragmenteo se ejecutará o no en función de una
    condición.
-   `for`: se ejecuta un bucle de forma definida según un número
    determinado de ocasiones.
-   `while`: ejecuta un bucle mientras sea verdadera una condición.

Junto a ellas, debemos tener presentes otras de uso menor como:

-   `repeat`: el bucle se ejecutará indefinidamente hasta que lo
    detengamos con `break`.
-   `next`: salta a la siguiente ejecución de un bucle.

\#\#\#`if/else` Como se ha dicho, esta estructura de control se
ejecutara o no, en función de que se cumpla una determinada condición.
De forma esquemática:

```{r eval=FALSE}
if(<condicion>) {
  ## bloque de código
}
```

O, en el caso de que queramos que se ejecute algo distinto a que
condición nos marca, podremos hacer:

```{r eval=FALSE}
if(<condicion>) {
  ## bloque de código
} else {
  ## otro bloque de código
}

```

Tambien podremos anidarlos:

```{r eval=FALSE}
if(<condicion1>) {
  ## bloque de código
} else if(<condicion2>) {
  ## otro bloque de código
} else {
  ## otro bloque de código
}
```

Veamos un ejemplo muy simple:

```{r eval=FALSE}
x <- runif(1, 0, 10)
if(x > 3) {
  y <- TRUE
} else {
  y <- FALSE
}
```

El anterior comando genera un objeto `x` cuyo valor se obtiene de forma
aleatoria entre 0 y 10. A continaución hacemos nuestro bucle: si `x` es
mayor de 3, se creará un objeto `y` con valor `TRUE`, mientras que si no
es así, `y` tomará el valor `FALSE`.

### `while`

A diferencia de el anterior con `while` comemza comprobando una
condición: si esta es verdadera, entonces se comienza con el bucle. Una
vez completada una ejecución de este bloque, se comprueba la condición
nuevamente y así sucesivamente hasta que la comprobación de la condición
de falso. Veamos su forma:

```{r eval=FALSE}
while(<condicion>) {
  # código
}
```

A modo de ejemplo:

```{r}
i <- 1
while (i < 6) {
print(i)
i = i+1
}
```

### `for`

Los bucles `for` son, con diferencia y por su versatilidad, los más
utilizados en R. En este caso, estos toman el valor que se asigna a
partir de los elementos de un objeto (generalmente listas) y, de forma
sucesiva, van ejecutando los ciclos. Esquemáticamente:

```{r eval=FALSE}
for(<variable> in <objeto iterable>) {
  # código a ejecutar
}
```

Por ejemplo:

```{r}
for(i in 1:5){
  print(i)
} 
  
```

Finalmente indicar que, como el anterior, podremos anidar unos dentro de
otros.

## Los gráficos en R

Si por algo destaca R es por su capacidad gráfica y por la flexibilidad
en la creación de los mismos ofreciendo una increíble variedad de
gráficos (Para tener una idea, escribe `demo(graphics)`).

De antemano se debe tener claro una cuestión para el aspecto gráfico en
R: el resultado de una función gráfica no puede ser asignado a un objeto
(recordemos que el resultado de una operación de análisis estadístico se
podia asignar a un objeto) si no que se muestra en el motor gráfico y
nada mas.

Existen dos tipos fundamentales de funciones gráficas: las funciones
gráficas de alto nivel que crean una nueva gráfica y las funciones
gráficas de bajo nivel que agregan elementos a una gráfica ya existente.

La instalación base de R trae una serie de gráficos que a buen seguro
son lo suficientemente versátiles para cumplir con todas nuestras
expectativas. Pero si con ellos no fuera suficiente, existen paquetes
adaptados a esta función que amplían la riqueza gráfica del sistema R.

La función usual de R para producir un gráfico es el comando `plot`:

```{r, fig.width=4, fig.heigth=4}
datos<-matrix(c(2,5,1,5,8,2,1,9,5,1,5,9), ncol=2) 
colnames(datos)<-c("Peso", "Estatura")
datos
plot(datos)
```

Si quisiéramos añadir una descripción a nuestro gráfico, podríamos usar
el comando `main` que pondrá un título al mismo. Además, podemos
detallar un poco más las descripciones de los ejes con `xlab` e `ylab`.
Obviamente, también podremos cambiar el color y el tipo de "punto"
usando `col` y `type`. Para finalizar, podríamos añadir una rejilla en
las marcas principales con `grid` y añadir un texto descriptivo con
`text` en una determinada coordenada. Veámoslos todos juntos:

```{r, fig.width=3}
plot(datos, main="Mi primer gráfico en R", xlab="Peso (kg)", ylab="Estatura (m)", col="red")
grid()
text(7, 8, "texto explicativo")
```

Seguimos ampliando las opiones de nuestro gráfico. En ocasiones podremos
desear añadir una determinada línea al mismo. para ello, nos podemos
servir de la función `abline`:

```{r, ffig.width=4, fig.heigth=4}
plot(datos, main="Mi primer gráfico en R", xlab="Peso (kg)", ylab="Estatura (m)", col="red", type="p")
 
abline(h=4, col="green") # Añade línea horizontal 
abline(v=6, col= "blue") # Análogo para línea vertical
abline(1,4, col="grey", lty=2) # Añade una línea de pendiente 1 y que corta al origen en 3 con trazo discontinuo
```

El sistema tradicional de gráficos ofrece una variedad de tipos de
gráficos básicos:

-   la función `plot()` produce gráficos de dispersión,
-   la función `barplot()` produce gráficos de barra,
-   la función `hist()` produce histogramas,
-   la función `boxplot()` produce gráficos de caja,
-   y la función `pie()` produce gráficos de tarta.

Hemos de tener presente que R no distingue más tipos de gráficos siendo
otros tipos de gráficos variaciones de estos principales. Por ello, un
gráfico de dispersión con sus puntos interconectados por una línea, es
una nueva orden en el comando `plot()`, denominada `type`:

```{r, fig.width=4, fig.heigth=4}
plot(datos, main="Mi primer gráfico en R", xlab="Peso (kg)", ylab="Estatura (m)", col="red", type="p")
plot(datos, main="Mi primer gráfico en R", xlab="Peso (kg)", ylab="Estatura (m)", col="red", type="l")
plot(datos, main="Mi primer gráfico en R", xlab="Peso (kg)", ylab="Estatura (m)", col="red", type="b")
plot(datos, main="Mi primer gráfico en R", xlab="Peso (kg)", ylab="Estatura (m)", col="red", type="h")
```

O, repeticiones más o menos complejas del gráfico principal como el
socorrido `pairs()` para ver correlaciones:

```{r}
data(iris)
names (iris)
pairs(iris[1:3], pch = 21)
```

Llegados a este punto, llega el momento de explicar un recurso del motor
gráfico de R: la organización de los gráficos en la ventana. Para ello
se utiliza la función `par()` que controla parámetros gráficos
adicionales. veamos como funciona:

```{r}
par(mfrow=c(2,1))      # Dibuja una matriz de gráficos 2x1: un gráfico debajo de otro
par(mfrow=c(2,3))      # Matriz de gráficos 2 x 3 : dos filas por tres columnas
par(mfrow=c(1,1))      # un solo gráfico por ventana: la opción por defecto
```

Un detalle más. Ciertos elementos tienen gráficos predefinidos, ya que
se sobreentiende que son de obligado diseño. Caso de esto pueden ser los
gráficos descriptivos de un modelo lineal, por ejemplo (olvidémonos de
la primera sintaxis, que se verá en capítulos más adelante):

```{r message=F, warning=F}

download.file("https://raw.githubusercontent.com/juliomsevilla/rlidar/main/data/parc.csv",
              destfile = paste(tempdir(), "\\parc.csv", sep=""), 
              method = "curl", overwrite=TRUE)

data <- read.csv(paste(tempdir(), "\\parc.csv", sep=""),header=TRUE)

datos.df<-data.frame(data)
model<-lm(VSC~HD, datos.df)
par(mfrow=c(2,2)) # De esta forma creamos una estructura gráfica de 2x2
plot(model)
par(mfrow=c(1,1)) # Y ahora volvemos a poner el sistema gráfico en su posición original
```

Una última cuestión. Hasta ahora hemos estado trabajando con un conjunto
de datos sencillo, compuesto por dos variables. En el caso de disponer
de más y querer representarlas, deberemos modificar nuestra sentencia
para indicar este hecho:

```{r, fig.width=4, fig.heigth=4}
plot(datos.df$VSC~datos.df$HD, main="Mi primer gráfico en R", xlab="Volumen (m3)", ylab="Altura (m)", col="red", type="p")
```

Como vemos las posibilidades gráficas de R son muy grandes y son objeto
de monografías exclusivas sobre sus capacidades.

### ggplot2

La librería ggplot2 [@R-ggplot2] es un paquete que se ha convertido en
un imprescindible dentro del sistema R por sus capacidades gráficas. Si
bien cambia un poco la concepción que hasta ahora tenemos de los
gráficos, los beneficios que nos reporta suplen con creces su aparente
complejidad.

Este paquete se basa en elaborar un gráfico a partir de un proceso de
acumulación de capas o layers siendo su esquema constante según la
siguiente expresión:

> ggplot(data.frame, aes(x = variable)) + geom_forma() + stat_valor

donde: - `data.frame` es nuestro objeto de datos (en formato
`data.frame`), - `aes()` controla la estética del gráfico, es decir los
elementos representables gráficamente (la posición x e y, el color,las
columnas de la tabla de datos...) - `geom_` lo define con puntos,
rectas, histogramas, densidades, etc. (además es capaz de superponer
distintas geometrías), - y `stat_()`, que es un resumen estdístico de
los datos asociado al tipo de geometría con que trabajamos.

Veamos un ejemplo:

```{r message=F, warning=F}


download.file("https://raw.githubusercontent.com/juliomsevilla/rlidar/main/data/Pesadas.txt",
              destfile = paste(tempdir(), "\\Pesadas.txt", sep=""),
              method = "curl", overwrite=TRUE)

arbol <- read.csv(paste(tempdir(), "\\Pesadas.txt", sep=""),sep="\t", header=TRUE)


arbol.df<-data.frame(arbol)
names(arbol.df)
library(ggplot2)
ggplot(arbol.df, aes(x =CLM)) + geom_bar()
```

Como vemos, le hemos indicado que utilice el conjunto de datos
`arbol.df`, que use en el eje horizontal los valores de `CLM` (al no
incluir datos en la vertical, realizará un conteo) y que el tipo de
gráfico sea de barras. En este punto, ggplot2 es muy versatil definiendo
el tipo de goemetría (o "gráfico") aceptando multitud de variaciones:
`geom_bar`, `geom_point`,`geom_boxplot`, `geom_violin`, `geom_line`,...

Una de las ventajas del uso de ggplot2 es que podemos guardar el gráfico
en un objeto y añadir más capas. Por ejemplo, añadamos las etiquetas de
los ejes y el título:

```{r, fig.width=3}
grafico<-ggplot(arbol.df, aes(x = CLM)) + geom_bar()
grafico+xlab("Monte") + ylab ("Número de individuos")+ggtitle("Gráfico de individuos")

```

Ahora vamos a controlar la estética del gráfico, haciendo que las barras
sean más pequeñas y cambien de color:

```{r}
grafico<-ggplot(arbol.df, aes(x = CLM)) + geom_bar(width=0.5, colour="black", fill="red")
grafico+xlab("Monte") + ylab ("Número de individuos")+ggtitle("Gráfico de individuos")

```

Los temas (theme) son un conjunto de opciones predefinidas sobre la
apariencia de los objetos en ggplot. El tema por defecto del ggplot
dibuja el gráfico sobre un fondo gris. Podemos cambiarlo a otro tema
añadiendo el comando especifico. En este caso usamos el `theme_bw()` (es
interesante el paquete `ggthemes` que incorpora una gran variedad de
ellos):

```{r}
grafico+theme_bw()
```

Ahora vamos a ir un paso más allá. Vamos a crear un grafico de
dispersión, comparando dos variables y usaremos el comando `facet` que
permite reproducir el mismo gráfico en diferentes niveles de un factor:

```{r}
#Version nº1
grafico<-ggplot(arbol.df, aes(x = Ht, y= Dn)) + geom_point(width=0.5, colour="black", fill="red")
grafico+xlab("Altura") + ylab ("Diametro")+ggtitle("Gráfico de individuos")+ facet_grid(CLM ~.)
#Version nº2
grafico<-ggplot(arbol.df, aes(x = Ht, y= Dn)) + geom_point(width=0.5, colour="black", fill="red")
grafico+xlab("Altura") + ylab ("Diametro")+ggtitle("Gráfico de individuos")+ facet_grid(.~ CLM)
```

¿Y si quisiéramos rotar los ejes para observar mejor nuestros datos?
Para ello podemos usar `coord_flip()`.

```{r}
grafico+xlab("log de la altura") + ylab ("Número de individuos")+ggtitle("Gráfico de individuos")+ facet_grid(.~ CLM)+coord_flip()
```

Para finalizar, veamos la opción ´stat´ que como dijimos es un resumen
estadístico de los datos asociado al tipo de geometría con que
trabajamos:

```{r}
grafico+xlab("Altura") + ylab ("Diametro")+ggtitle("Gráfico de individuos")+ stat_smooth()
grafico+xlab("Altura") + ylab ("Diametro")+ggtitle("Gráfico de individuos")+ stat_smooth(method=lm)
```

En definitiva, las posibilidades son casi infinitas y evidentemente
escapa a los propósitos de este manual. Si se desea saber más sobre este
paquete, podemos consultar su manual oficial: [ggplot2: Elegant Graphics
for Data Analysis](http://ggplot2.org/book/).

## Las funciones en R

Generalmente nuestros análisis consisten en una secuencia de comandos de
R (posiblemente insertados dentro de un fichero `.Rmd`) que se ejecutan
secuencialmente. En ocasiones, sin embargo, es conveniente crear
funciones, por ejemplo, cuando hay operaciones comunes que se realizan
reiteradamente (incluso en análisis distintos). Estas funciones
podríamos equipararlas a las tan conocidas *macros*.Estas funciones en R
requieren una bibliografía específica y son un capítulo aparte dentro de
este lenguaje de programación, por lo que solo vamos a dar unas
pinceladas para que se entiendan las funciones que se han plasmado a lo
largo de este manual.

Las funciones en R son tratadas como cualquier otro objeto y para
crearlas utilizamos el comando `function()`, el cual creará un objeto de
tipo `function`, para, a continuación llamarla, escribiendo el nombre de
la misma. La estructura básica es la siguiente

```{r eval=FALSE}
f <- function(argumentos) 
{
  ## comandos de la función (body)
}
```

Veamos un ejemplo:

```{r}
f <- function() 
{
  cat("Hola Mundo")
}

f()
```

En este punto ya habremos llegado a la conclusión de donde está el final
del camino de las funciones: sí, en los paquetes. Un paquete no es más
que un conjunto de funciones, ordenadas y estandarizadas, de tal forma
que puedan ser replicables en todos nuestros análisis, y, si así lo
decidimos que otros puedan usarlas si las compartimos libremente.

### Estructura de una función

Las funciones en R se componen de tres partes fundamentales:

-   el cuerpo (body),
-   los argumentos (formals) y
-   el ambiente (environment)

```{r eval=FALSE}
f <- function(x, y) { x + y }

body(f)
{
 x + y
}

formals(f)
$x
$y


environment(f)
<environment: R_GlobalEnv>
```

El cuerpo es la sucesión de códigos y comandos que la función ejecutará
para realizar los propósitos que le pedimos, mientras que los argumentos
son una serie de valores que se le pasan a la función de forma que
ciertas variables dentro de la función tomen diversos valores. Ambios
son obligatorios para confeccionar nuestra función. Es importante
indicar que el orden con el que se incluyan en la declaración de la
variables es como se ubicarán en la función:

```{r}
area_rectangulo <- function(lado1, lado2) 
{
  area <- lado1 * lado2
  print(paste("el área es ", area))
}
area_rectangulo(lado1 = 2, lado2 = 3)
"el área es  6"
```

## Publicación de resultados

Como hablamos, el sistema R no destaca especialmente por tratarse de un
sistema visual y amigable para los usuarios noveles que se enfrentan a
él. Ello se hace extensible a la publicación de los resultados, quizás
el aspecto menos desarrollado del software.

Esta carencia ha sido suplida, como no, por librerías que hacen más
sencillo el formateo de los resultados, su publicación y divulgación. En
concreto, y sobre cualquier otras, destacan las siguientes:

-   `knitr` [@R-knitr], que permite la confección de informes dinámicos
    y reproducibles (esto es que se pueden modificar cada vez que
    rehagamos algo en nuestro código), que permite integrar el lenguaje
    R en otros documentos construidos en `LaTeX`, `HTML`,
    `Markdown`,...\
    Muy brevemente podríamos decir que `knitr` se basa en dos conceptos:
    el fragmento literal de texto, escrito comúnmente en `Markdown` y el
    fragmento de código R o `chunk` (la unión de ambos es lo que se
    conoce como `RMarkdown`). Una vez compilamos nuestro informe
    (proceso para lo cual se apoya en el software `pandoc`) tendremos,
    por un lado el texto formateado, según las características que
    hayamos definido en el encabezado del documento y los resultados de
    los códigos, embebidos en el mismo. Entre las salidas básicas
    tendremos el formato `HTML`, `docx` y `pdf`, si bien podremos
    generar muchos más gracias a las excepcionales posibilidades que da
    `Pandoc`.

-   `shiny` [@R-shiny], que se basa en el uso de Programación Reactiva
    (Reactive Programming), esto es, existen unos valores que pueden
    variar en el tiempo y que son registrados por unas expresiones que
    posteriormente las reproducen. Junto a este motor de razonamiento,
    incorpora, adaptadas, los clásicos elementos HTML (botones, cuadros
    de texto, barras de desplazamiento,...) junto con las potentes
    gráficas de R y su estructura de datos. Básicamente se compone de
    dos ficheros que se crean en nuestro directorio local: `ui.R`, que
    gestiona la salida visual y el aspecto de la aplicación y `server.R`
    con las instrucciones para que la misma función, siendo en esta
    última donde se embebe el motor de cálculo en realizado en R. Estos
    archivos, que ya en las últimas versiones se encuentran embebidos en
    uno solo `app.R`, son publicados en nuestro servidor web o en las
    distintas plataformas que lo interpreten, como GitHub.\
    Las posibilidades de `shiny` se amplían al admitir incorporaciones
    al código nativo de todos los elementos que actualmente conforman
    los ecosistemas `HTML`, `CSS` y `Javascript`, lo que implica que los
    desarrollos que se puedan hacer con esta herramienta son casi
    ilimitados. Esto la convierte en una herramienta muy poderosa para
    la construcción de cuadros de mando y para mostrar los resultados de
    nuestros desarrollos usando las capacidades analíticas de `R`, de
    forma que el receptor de nuestra información pueda interactuar
    fácilmente con ella.

-   `flexdashboards` [@R-flexdashboard], que permite, de una forma
    extremadamente simple, crear cuadros de mando dinámicos e
    interactivos a partir de código `Markdown`. Muy parecido en concepto
    a `shiny` esta librería es adecuada si solo deseamos publicar
    nuestros resultados en formato de cuadro de mando y se busca (por
    ahora...) una menor interacción del usuario.

### La escritura con Markdown

Markdown es un lenguaje de marcado ligero ideado en 2004 por John
Gruber, con la visión de crear un lenguaje sencillo, fácil de leer y de
escribir, aprovechando las ventajas del lenguaje `HTML` pero eliminando
sus inconvenientes, como por ejemplo las etiquetas, que tanto engorran
el código. Pongamonos en situación: si estamos escribiendo en `HTML`,
para añadir una palabra en negrita deberíamos escribir
`<strong>importante</strong>` mientras que si estamos escribiendo en
`Markdown`nos bastaría poner `**importante**` para que cuando lo
compilemos, se muestre de esta forma. Huelga decir, que en un procesador
de textos al uso deberemos dejar de escribir, coger el ratón, pulsar en
el botón de la negrita, volver a escribir, de nuevo coger el ratón, ir a
la barra de herramientas, desactivar el formato de negrita y continuar
escribiendo (...). A continuación podemos ver algunos ejemplos de la
notación de este lenguaje:

![](https://raw.githubusercontent.com/juliomsevilla/rlidar/main/images/markdown.png)
