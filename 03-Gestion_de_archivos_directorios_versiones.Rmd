---
output:
  pdf_document: default
  html_document: default
---
# Gestión de directorios, archivos y versiones {#files}

## Gestión de directorios
Existen dos comandos básicos para trabajar con directorios: `setwd()` y `getwd()`. El primero, fija el directorio de trabajo que deseamos y el segundo lo llama. 

Con el directorio fijado, podremos movernos por él, usando el comando `"./data"` que nos haría descender a una carpeta llamada data que cuelga de nuestro directorio raíz fijado con `setwd()`. Por otro lado, si usamos el comando `"../data"` ascenderemos a una carpeta que esta en un nivel superior a nuestro directorio raíz.

A continuación, podemos usar los comandos `list.files()` y `list.dirs()` para poder listar los archivos y directorios respectivamente que tengamos en el directorios elegido. Es interesante indicar que si añadimos la opción `recursive=TRUE` los dos comandos listaran todos los ficheros y archivos que haya tanto en nuestro directorio raiz como en todos los inferiores. Finalmente, usando el comando `full.names = TRUE` en vez de solo mostrarnos el nombre completo del fichero, nos mostrará toda su ruta.

Ahora combinemos todo lo anterior para listar los ficheros de un directorio:

```{r eval = FALSE}
list.files("c:/")
list.dirs("c:/")
```

Finalmente, con el comando `pattern =` podremos seleccionar determinados ficheros o directorios que coincidan con una determinada condición. Por ejemplo, `pattern = "(.*).jp2$"` nos mostrará todos los ficheros que finalicen la extensión `jp2` y `pattern = "29SMD(.*)SCL_20(.*).jp2$"` nos listará todos los ficheros que además de finalizar con `jp2`incluyan la cadena `29SMD` y `SCL_20`.

Una vez tenemos claro los conceptos anteriores, podremos realizar trabajos recursivos con nuestros ficheros y directorios (tranquilo, comprenderás este código a lo largo de estos apuntes), por ejemplo:

```{r eval = FALSE}
List <- list.files(getwd(), full.names = TRUE, 
                   pattern = "29SMD(.*)SCL_20(.*).jp2$", 
                   recursive=TRUE) 
for (file in List) { 
  out_file <- extension(file, 'tif') 
  gdal_translate(src_dataset = file, dst_dataset = out_file, 
                 ot = "UInt16", of = "GTiff") 
} 
```

## Manejo de archivos

Cuando cargamos un fichero externo, sea del formato que sea, R, por defecto lo interpretará como un `data.frame` (ver \@ref(dataframe)), si este viene en un formato usual de tabla.

R puede cargar multitud de ficheros distintos y si no lo hace con las opciones incluidas en ´{base}´ lo hará a traves de librerias. Veamos a continuación los más frecuentes.

### Ficheros csv

Los ficheros delimitados por comas se cargan con el comando `read.csv` indicando al menos la ruta del mismo, si viene o no con cabeceras, el separador decimal y el separador de colummas: 

```{r eval = FALSE}
datos<-read.csv("./datos.csv", header=TRUE, dec= ".", sep=",")
```

En el caso de no indicar, `header`, `dec` y/o `sep`, el comando `read.csv` importará el fichero con el primer registro como cabeceras, el separador decimal en forma de `.` y el separador de columnas `,`.

En ocasiones, nuestro fichero puede venir sin cabeceras por lo que deberemos importarlo indicando este echo y R se encargará de crearlas y nombrarlas automaticamente:

```{r eval = FALSE}
datos<-read.csv("./datos2.csv", header=FALSE, dec= ".")
```

En este último caso, si deseamos que en vez de los nombres de cabecera que crea R, tener unos personalizados, deberemos decírselo al realizar la importación:

```{r eval = FALSE}
datos<-read.csv("./datos2.csv", header=FALSE, 
                dec= ".", col.names = c("id", "factor", "volumen"))
```

Para finalizar, nuestros ficheros pueden venir con valores nulos. Si los conocemos, deberemos indicarselo al comando `read.csv` mediante `strings.na`. Por ejemplo (todos los valores que en el fichero vengan con `N/A` los entederá como un valor nulo):

```{r eval = FALSE}
datos<-read.csv("./datos3.csv", header=TRUE, strings.na= "N/A")
```

Un añadido: en ocasiones los ficheros comienzan con líneas explicativas que no sirven para nada en el contexto de datos tabulares. Para saltar estas lineas podemos usar el comando `skip=` dentro de `read.csv()`.

### Carga de datos usando el buscador
En ocasiones, sobre todo si nuestro código lo compartimos con otros, es conveniente dejar la forma de entrada de nuestros datos a libre elección y que se localicen con el buscador del sistema. Para ello, haremos uso de la función `file.choose()`:
```{r eval = FALSE}
filename <- file.choose()
data <- read.csv(filename, header=TRUE, dec= ".", sep=",")
```


### Carga de datos desde una ruta web

Generalmente nuestros ficheros estarán alojados en nuestro PC, pero en la actualidad, cada vez es más frecuente que los mismos estén alojados en un servidor de la web. La carga de estos no difiere en nada de la carga de un fichero ubicado en nuestro local. Para ello, en vez de una ruta de carpetas de nuestra computadora, pondremos la url donde se aloje el fichero y nos ayudaremos de la libreria `RCurl` [@R-RCurl] que facilita el trabajo de lectura y descarga:

```{r eval = FALSE, message=F, warning=F}
library(RCurl)
datos_online <- read.csv(
  text=getURL("https://gitlab.com/juliomsevilla/Rintro/raw/master/data/parc.csv"), 
  header=TRUE)
```

### Scrapping

Una rutina bastante usual es descargar datos desde una web (a diferencia del anterior, no es un fichero alojado en una servidor). A este procedimiento se le denomina *scrapping* y usualmente deberemos comprender ficheros del tipo `xml`o `json` (comprender, ya que no son estructuras rígidas como puede ser una "tabla" de un `csv`). 

En el caso de `xml` nos apoyaremos en la libreria `XML` [@R-XML] el procedimiento consistirá en cargar la ruta en la que se aloja dicho elemento y a continuación indicarle a `R` cual es el nodo raíz para finalmente ver que datos hay encerrados entre las etiquetas `<>`.

```{r eval = FALSE, message=F, warning=F}
library(XML)
library(RCurl)
url<-getURL("https://gitlab.com/juliomsevilla/Rintro/raw/master/data/test.xml")

xmldoc<-xmlParse(url)
rootnode<-xmlRoot(xmldoc)
rootnode[1] #De esta forma podremos ver el registro número 1

datos_raw<-xmlSApply(rootnode, function(x) xmlSApply(x, xmlValue)) #Carga los datos fila a fila
datos<-data.frame(t(datos_raw), row.names =NULL) #Hacemos una transposición para aplicar correctamente las etiquetas como cabeceras

```

Como sabemos `HTML` no deja de ser una formulación especial de `xml` y, por tanto, podremos usar lo anterior para extraer información de una web, web, hecha con lenguaje `HTML`

```{r eval = FALSE}
url<-getURL("https://gitlab.com/juliomsevilla/Rintro/raw/master/data/poblacion.html")
tables<-readHTMLTable(url) #Nos extrae todas las tablas que hay en el fichero HTML
tabla1<-tables[[3]] #Extraerá la tabla 6 y se usan dos corchetes porque se busca en una lista de listas
tabla2<-readHTMLTable(url, which=3) #Idem al anterior pero no cargamos en local toda la web, ahorrando memoria

```

Ahora hablemos de los ficheros `json` ficheros mucho más comunes para compartir datos y más eficientes en este sentido que `xml`. la librería que nos facilita el trabajo es `jsonlite` [@R-jsonlite]
```{r eval = FALSE, message=F, warning=F}
library(jsonlite)
library(RCurl)
url<-"https://gitlab.com/juliomsevilla/Rintro/raw/master/data/currencies.json"
currencies<-fromJSON(url)
```
Si analizamos la estructura del fichero `json`veremos que como en el caso de `xml`es un conjunto de tados anidadados en etiquetas. Para poder extraer solo lo que nos interesa, podemos hacer uso del simbolo `$` y crearnos un solo objeto con los datos que nos interese (es bastante util ir recorriendo la estructura según nos propone el predictor de `RStudio` a medida que vamos poniendo el símbolo `$`)
```{r eval = FALSE}
datos<-currencies$list$resources$resource$fields
```


### El fichero Rdata
`R` por defecto trabaja con un sistema de archivos propio, denominado con la extensión `*.Rdata`. Estos ficheros conservará todos los elementos tal y como los tengamos en la memoria una vez lo creemos, por lo que resultan bastante útiles para compartir ciertos elementos de nuestras sesiones que hayamos trabajado.

```{r eval = FALSE}
cliente<-c("Pepe", "Juan", "Julio")
fecha<-as.Date(c("2018/1/14", "2018/12/26", "2018/11/15"))
cantidad<-c(11.1, 16.18, 26.25)
datos<-data.frame(cliente, fecha, cantidad)
save(datos, currencies, file = "c:/Borrar/clientes.Rdata")
load("c:/Borrar/clientes.Rdata")
```

Existe otro formato de fichero en R, denominado `rds` que difiere del anterior en que este no almacena el nombre del objeto, por lo que cuando lo carguemos deberemos asignarle el nombre que queramos tener en nuestra sesión y, y esto es lo más importante, solo es capaz de guardar un solo objeto. Para guardar o cargar este fichero, usaremos los comandos `loadRDS` y `saveRDS` (en este último caso, guardando con la extensión `*.rds`).

Finalmente, dentro de `R` podemos usar un comando muy interesante: `save.image(file="")` el cual nos permite guardar en un fichero `Rdata` toda nuestra sesión, permitiéndonos así hacer portable nuestro trabajo.

## Limpieza de la memoria en `R`
A medida que vayamos trabajando en nuestro análisis, la memoria del sistema se irá llenando pudiendo llegar a abortar la sesión (depende la memoria RAM de nuestra computadora). Por ello, es recomendable ir eliminando aquellos objetos que no vayamos a utilizar nuevamente con el comando `rm`:

```{r eval = FALSE}
rm(datos, tabla1) #Elimina el objeto datos y tabla1
rm(list=setdiff(ls(), c("cantidad", "cliente"))) #Elimina todos los objetos de la memoria menos
rm(list=ls()) #Elimina todos los elementos de la memoria
.rs.restartR() #Reinicia la sesión de R, eliminando cualquier resto que pudiera quedar
```

## Control de versiones

Para comenzar necesitaremos contar con el software Git en nuestro pc. Podemos hacerlo de dos formas: descargandolo e instalando la versión de nuestro sistema operativo o usando una versión portable. Desde aquí recomendamos [https://www.syntevo.com/smartgit/download/](Smartgit portable), bien para usarlo o solo para utilizar el git portable. 

Una vez lo descomprimes vamos a RStudio y en Tools>Global Options>Git/SVN se le indica donde está git.exe, que está dentro de la instalación de git portable en la carpeta bin (generalmente en /git/bin/git.exe).

A continuación abrimos el shell de git (/git/git-cmd.exe) y pondremos los siguientes comandos sustituyendo con nuestros datos lo que viene dentro de las comillas. 

`git config --global user.name 'Your Name'`

`git config --global user.email 'your@email.com'`

Crear un proyecto control de versiones es muy sencillo: creamos el proyecto habilitando el sistema de versioneado (checkbox “Create a git repository” dentro de File>New Directory>New Project). Para clonar un repositorio creamos un nuevo proyecto y le decimos que este sea con control de versiones (File>Version Control) y ahí podremos introducir la dirección http del repositorio. También tendremos que indicarle donde lo guardaremos. Despues de ello, RStudio añadirá un botón, en la barra de herramientas principal, para gestionar el control de versiones (simbolizado con las letras GIT).

Trabajar con un sistema de control de versiones daría para un libro completo sobre el tema por lo que no vamos a profundizar. Básicamente, nuestro trabajo se basará en realizar commits cada vez que deseemos fijar una foto de nuestros cambios y ejecutar pull/push de nuestros repositorios cuando queramos traernos los cambios a local o subirlos al servidor respectivamente. Indicar que en estas dos acciones, se abrirá un diálogo que nos solicita nuestro usuario y contraseña. Para profundizar en el tema es muy recomendable visitar el manual de Jenny Bryan [Happy Git and GitHub for the useR](http://happygitwithr.com/) y el video oficial de RStudio dentro de la serie [RStudio Essentials](https://www.rstudio.com/resources/webinars/rstudio-essentials-webinar-series-managing-part-2/) 

## Buenas prácticas en la gestión de un proyecto
Con frecuencia nos veremos envueltos en la gestión de proyectos de envergadura donde se mezclarán ficheros de datos creados y externos, scripts, elementos de consulta, documentación e incluso información temporal. Por ello, es recomendable ser disciplinado y crear una estructura de directorios adecuada.

A continuación se dan unas ideas, adecuables a cada situación:

1. Tratar los datos originales como de sólo lectura
2. Limpiar los datos previamente, incluso fuera de R
3. Usar herramientas de control de versiones como `Git` o `SVN`
4. Empezar siempre nuestra sesión definiendo el directorio de trabajo y que este sea fijo
5. Siempre trabajar con la misma estructura de directorios, aunque tengamos carpetas vacias. Por ejemplo, dentro de del directorio raíz de nuestro proyecto (cada proyecto contará con uno), crear las siguientes carpetas:
    * bin: para guardar todos aquellos elementos accesorios para poder realizar los análisis (scripts de otros lenguajes, por ejemplo)
    * data: donde almacenaremos todos los datos de inicio, metadata,...
    * doc: para poder guardar toda la documentación generada como wikis o manuales
    * results: para guardar los datos limpios de nuestro análisis y los resultados
    * src: para almacenaje de scripts creados
    * temp: para almacenar los archivos temporales y prescindibles
6. Escribir código legible y que este sea lo más pequeño posible ("un elefante nos lo podemos comer a pequeños bocados")
7. Siempre documentar tu proyecto, hasta lo más simple